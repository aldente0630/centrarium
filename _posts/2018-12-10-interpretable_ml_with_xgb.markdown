---
layout: post
title: 해석가능한 XGBoost 기계학습
date: 2018-12-10 00:00:00
author: Scott Lundberg
categories: Data-Science
---  
  
  
**Scott Lundberg의 [*Interpretable Machine Learning with XGBoost*](https://towardsdatascience.com/interpretable-machine-learning-with-xgboost-9ec80d148d27)를 번역했습니다.**
  
  
- - -

기계 학습 모형을 잘못 해석할 때의 위험성 그리고 올바르게 해석할 때의 가치에 관한 이야기다. 그래디언트 부스팅 머신이나 랜덤 포레스트 같은 앙상블 트리 모형의 굳건한 정확도를 확인했다면, 또 결과를 해석해야 한다면 유익하고 도움이 될 것이다.

은행에서 고객의 재정 상태를 예측하는 업무가 있다고 상상해보자. 모형이 정확할수록 은행은 많은 돈을 벌겠지만 예측값이 대출 신청에 사용될 터이니 해당 예측을 한 합법적 이유를 설명해야 한다. 여러 모형을 실험한 결과 XGBoost가 구현한 그래디언트 부스팅 트리 정확도가 가장 높다는 걸 알았다. XGBoost 예측의 이유를 설명하긴 까다로워 보이므로 선형 모형으로 돌아가거나 XGBoost 모형을 해석할 수 있는 방안을 고심해봐야 한다. 데이터 과학자라면 정확도를 포기하고 싶지 않을 것이기에 후자를 시도하며 복잡한 XGBoost 모형(깊이가 6인 1,247개의 트리)을 해석해보기로 결정했다.
  
## 고전적인 전역 변수 중요도 측정
  
첫 번째 확실한 선택은 파이썬 XGBoost 인터페이스에서 plot_importance() 메서드를 사용해 보는 것이다. 이 방법은 데이터셋 각 변수의 중요도를 나타내는 흥미롭고 단순한 막대 차트를 제공한다(본문을 재현하는 코드는 [주피터 노트북](https://slundberg.github.io/shap/notebooks/Census+income+classification+with+XGBoost.html)에 있음)

![그림1](https://aldente0630.github.io/assets/interpretable_ml_with_xgb1.png)
고전적인 “성인” 인구 조사 데이터셋에서 각 사람의 수입이 50만 달러 이상일지 예측하기 위해 (로지스틱 손실을 적용하여) 훈련시킨 모형에 xgboost.plot_importance(model)을 실행한 결과.
  
XGBoost가 출력한 변수 중요도를 보면 다른 변수를 뛰어넘는 가장 중요한 수입에 관한 예측 변수로 *연령*을 꼽을 수 있다. 여기서 멈추고 관리자에게 *나이*가 가장 중요한 변수이고 *주당 근무 시간*과 *교육 수준*이 뒤를 잇는다고 직관적으로 만족할법한 보고를 드릴 수 있다. 그러나 좋은 데이터 과학자라면 문서를 보고 XGBoost에 변수 중요도를 측정하는 세 가지 옵션이 있음을 확인할 것이다.

1. **가중치.** 모든 트리에서 각 변수가 데이터를 분할하는 데 사용된 횟수.
2. **적용 범위.** 모든 트리에서 각 변수가 데이터를 분할하는 데 사용된 횟수. 단, 분할을 거치는 훈련 데이터 개수에 따라 가중치를 적용함.
3. **이득.** 분할에 각 변수를 사용할 때마다 감소한 평균 훈련 손실.

이는 트리 기반 모델링 패키지에서 찾을 수 있는 중요도의 대표적 척도이다. 가중치가 기본 옵션이었기에 다른 두 가지 접근법과 차이가 있는지 살펴보았다.
  
![그림2](https://aldente0630.github.io/assets/interpretable_ml_with_xgb2.png)
importance_type = “cover”와 importance_type = “gain” 모두 사용하여 xgboost.plot_importance를 실행한 결과.
  
**XGBoost에서 제공하는 세 가지 옵션마다 변수 중요도 순서가 매우 다르다는 사실을 알게 되었다!** 적용 범위 방법을 보면 *자본 이익* 변수가 소득에 대해 가장 중요한 예측 변수인 것처럼 보이지만 이득 방법을 보면 *결혼 상태* 변수가 다른 모든 변수를 압도한다. 어떤 방법이 가장 적합한지 알지 못한 채 변수 중요도 보고가 이런 척도 선택에 달려있다는 점은 마음을 매우 불편하게 만든다.

## 변수 중요도를 측정하는 기준으로 어떤걸 좋고 나쁘다고 할 수 있을까?
  
변수 기여도를 측정하는 하나의 방식을 다른 방식과 비교할만한 기준은 명확하지않다. 데이터 정리, 편향 탐지 등의 작업을 통해 각 방식의 최종 사용자 성능을 측정해볼 수 있겠다. 그러나 이 작업은 변수 기여도 분석 방식의 품질에 관한 간접적 측정이 될 뿐이다. 대신 여기서 변수 기여도 방식이 가져야할 두 가지 좋은 성질을 정의해보자.
  
1. **일관성.** 변수를 더 많이 사용하게끔 모형을 변경할 때마다 기존 변수가 기여한 중요도가 감소하지 말아야한다.
2. **정확성.** 각 변수 중요도의 합계가 모형의 전체 중요도여야한다. 예를 들어 중요도가 R<sup>2</sup> 값으로 측정되는 경우 각 변수 기여도의 합이 전체 모형 R<sup>2</sup>이 되어야 한다.
  
일관성이 유지되지 못하면 임의의 두 모형 간 변수 기여도를 비교할 수 없다. *기여도가 더 높기 때문에 모형이 실제로 해당 변수에 더 의존한다고 말할 수 없기 때문이다.*
  
정확성이 유지되지 못하면 각 변수의 기여도가 결합되어 전체 모형 출력값으로 나타나는 과정을 알 수 없다. 방식의 일관성이 깨질 수 있기 때문에 방식을 수행한 다음 기여도를 정규화시키는 일도 할 수 없다.  

## 현재의 기여도 방식은 일관되고 정확한가?
  
은행의 데이터 과학자 입장으로 돌아가면... 일관성과 정확성이 중요하다는 걸 이제 알고 있다. 사실 방식의 일관성이 없다면 가장 높은 기여도를 가진 변수가 실제로 제일 중요하리라는 보장이 없다. 그래서 은행 업무와 관련 없는 매우 간단한 트리 모형 두 개를 사용하여 각 방식의 일관성을 점검해보자.

![그림3](https://aldente0630.github.io/assets/interpretable_ml_with_xgb3.png)
2개의 변수를 사용한 간단한 트리 모델링. 기침은 모형 A보다 명백히 모형 B에서 중요하다.
  
모형 결과값은 개인 증상을 바탕으로 한 위험 점수이다. 모형 A는 *열*과 *기침*의 이진값 변수에 대한 단순 "and" 함수에 지나지 않는다. 모형 B는 같은 함수지만 *기침*이 예인 경우 +10이다. 일관성을 확인하기 위해 "중요도"를 정의해야한다. 여기서 중요도는 다음 두 가지 방법으로 정의할 것이다. 1) 일련의 변수를 제거할 때 변하는 모형의 기대 *정확도*와 2) 일련의 변수를 제거할 때 변하는 모형의 예상 *출력값*.
  
중요도의 첫 번째 정의는 변수의 모형에 대한 전체적인 영향을 측정한다. 두 번째 정의는 변수의 단일 예측값에 대한 개별적인 영향을 측정한다. 단순 트리 모형의 경우, *기침* 변수는 전체적인 중요도, *열*과 *기침*이 모두 예일 때의 개별 예측 모두 모형 B에서 명백히 더 중요하다.
  
위 *가중치*, *적용 범위*와 *이득* 방식은 모두 각 변수의 전체적인 기여도를 측정하는 방식이다. 그러나 모형을 은행에 배포할 때는 각 고객에 대해 개별적인 설명이 필요하다. 일관성을 확인하기 위해 단순 트리 모형에서 5개의 상이한 변수 기여도 방식을 수행했다.
  
1. **트리 SHAP.** 우리가 제안하고있는 새로운 개별화 된 방법.
2. **사바.** 개별화 된 휴리스틱 피처 속성 방법.
3. **평균 (\| 트리 SHAP \|).** 개별화 된 Tree SHAP 속성의 평균 크기를 기반으로하는 전역 속성 지정 메소드입니다.
4. **이득.** 위에서 설명한 XGBoost에서 사용한 것과 동일한 방법이며 Scikit-Learn 트리 모델에서 사용되는 Gini 중요도 측정과 동일합니다.
5. **스플릿 카운트.** XGBoost에서 밀접하게 관련된 "가중치"및 "표지"방법을 모두 나타내지 만 "가중치"방법을 사용하여 계산됩니다.
6. **순열.** 단일 피처가 테스트 데이터 세트에서 무작위로 치환 될 때 결과적으로 모델의 정확도가 떨어집니다.  

![그림4](https://aldente0630.github.io/assets/interpretable_ml_with_xgb4.png)
여섯 가지 방법을 사용하여 모델 A와 모델 B에 대한 피처 속성을 구합니다. 우리가 알 수 있듯이이 방법은 문헌에서 모든 트리 고유의 속성 귀속 방법을 나타냅니다.
  
(번역 중)
